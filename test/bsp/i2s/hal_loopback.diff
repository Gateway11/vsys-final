diff --git a/hal/AudioStream.cpp b/hal/AudioStream.cpp
index cc60b0e0..2598873b 100644
--- a/hal/AudioStream.cpp
+++ b/hal/AudioStream.cpp
@@ -64,7 +64,8 @@
 #define TS_TO_NS(ts) (((ts).tv_sec * 1000000000LL) + (ts).tv_nsec)
 #define RAMP_UP_DELAY 80 //80ms
 
-static bool karaoke = false;
+static bool karaoke = false, dpin_loopback = false;
+static uint32_t test_index = 0;
 std::mutex StreamOutPrimary::sourceMetadata_mutex_;
 std::mutex StreamInPrimary::sinkMetadata_mutex_;
 
@@ -2240,6 +2241,8 @@ int StreamOutPrimary::Start() {
     }
     if (karaoke)
         AudExtn.karaoke_start();
+    if (dpin_loopback)
+        AudExtn.dpin_loopback_start();
     stream_mutex_.unlock();
     AHAL_DBG("Exit ret: %d", ret);
     return ret;
@@ -2463,6 +2466,19 @@ int StreamOutPrimary::Standby() {
             }
         }
     }
+    if (dpin_loopback) {
+        ret = AudExtn.dpin_loopback_stop();
+        if (ret) {
+            AHAL_ERR("failed to stop dpin loopback path.");
+            ret = 0;
+        } else {
+            ret = AudExtn.dpin_loopback_close();
+            if (ret) {
+                AHAL_ERR("failed to close dpin loopback path.");
+                ret = 0;
+            }
+        }
+    }
 
     if (mmap_shared_memory_fd >= 0) {
         close(mmap_shared_memory_fd);
@@ -3482,6 +3498,18 @@ int StreamOutPrimary::Open() {
             karaoke = false;
         }
     }
+    if (mPalOutDevice[mAndroidOutDevices.size()-1].id == PAL_DEVICE_OUT_USB_HEADSET && ++test_index % 2 == 0) {
+        dpin_loopback = true;
+    }
+
+    AHAL_ERR("############################iiiiii##### DPin Loopback %d, test_index %d", dpin_loopback, test_index);
+    if (dpin_loopback) {
+        ret = AudExtn.dpin_loopback_open(mPalOutDevice[mAndroidOutDevices.size()-1].id, &pal_callback, ch_info);
+        if (ret) {
+            AHAL_ERR("DPin Loopback Open Error (%x)", ret);
+            dpin_loopback = false;
+        }
+    }
 
     //TODO: Remove below code, once pal_stream_open is moved to
     //adev_open_output_stream
@@ -3823,6 +3851,15 @@ ssize_t StreamOutPrimary::configurePalOutputStream() {
                 ret = 0; // Not fatal error
             }
         }
+        if (dpin_loopback) {
+            ret = AudExtn.dpin_loopback_start();
+            if (ret) {
+                AHAL_ERR("failed to start dpin loopback stream. ret=%d", ret);
+                AudExtn.dpin_loopback_close();
+                dpin_loopback = false;
+                ret = 0; // Not fatal error
+            }
+        }
         stream_started_ = true;
 
         if (CheckOffloadEffectsType(streamAttributes_.type)) {
diff --git a/hal/audio_extn/AudioExtn.cpp b/hal/audio_extn/AudioExtn.cpp
index df3b22fc..fe9fe877 100644
--- a/hal/audio_extn/AudioExtn.cpp
+++ b/hal/audio_extn/AudioExtn.cpp
@@ -955,6 +955,97 @@ int AudioExtn::karaoke_close(){
 }
 // END: KARAOKE ====================================================================
 
+// START: DPin Loopback  ===========================================================
+int AudioExtn::dpin_loopback_open(pal_device_id_t device_out, pal_stream_callback pal_callback, pal_channel_info ch_info) {
+    std::shared_ptr<AudioDevice> adevice = AudioDevice::GetInstance();
+    const int num_pal_devs = 2;
+    struct pal_device pal_devs[num_pal_devs];
+    dpin_loopback_stream_handle = NULL;
+    //pal_device_id_t device_in = PAL_DEVICE_IN_AUX_DIGITAL;
+    pal_device_id_t device_in = PAL_DEVICE_IN_HANDSET_MIC;
+    dynamic_media_config_t dynamic_media_config;
+    size_t payload_size = 0;
+
+    AHAL_DBG("###### DPin Loopback enter");
+    // Configuring Hostless Loopback
+    if (device_out != PAL_DEVICE_OUT_USB_HEADSET && device_out != PAL_DEVICE_OUT_BLUETOOTH_A2DP) {
+        return 0;
+    }
+
+    sattr.type = PAL_STREAM_LOOPBACK;
+    sattr.info.opt_stream_info.loopback_type = PAL_STREAM_LOOPBACK_KARAOKE;
+    sattr.direction = PAL_AUDIO_INPUT_OUTPUT;
+    sattr.in_media_config.sample_rate = DEFAULT_OUTPUT_SAMPLING_RATE;
+    sattr.in_media_config.bit_width = CODEC_BACKEND_DEFAULT_BIT_WIDTH;
+    sattr.in_media_config.ch_info = ch_info;
+    sattr.in_media_config.aud_fmt_id = PAL_AUDIO_FMT_DEFAULT_PCM;
+    sattr.out_media_config.sample_rate = DEFAULT_OUTPUT_SAMPLING_RATE;
+    sattr.out_media_config.bit_width = CODEC_BACKEND_DEFAULT_BIT_WIDTH;
+    sattr.out_media_config.ch_info = ch_info;
+    sattr.out_media_config.aud_fmt_id = PAL_AUDIO_FMT_DEFAULT_PCM;
+    for (int i = 0; i < num_pal_devs; ++i) {
+        pal_devs[i].id = i ? device_in : device_out;
+        if (device_out == PAL_DEVICE_OUT_USB_HEADSET || device_in == PAL_DEVICE_IN_USB_HEADSET) {
+            //Configure USB Digital Headset parameters
+            pal_param_device_capability_t *device_cap_query = (pal_param_device_capability_t *)
+                                                       malloc(sizeof(pal_param_device_capability_t));
+            if (!device_cap_query) {
+                AHAL_ERR("Failed to allocate mem for device_cap_query");
+                return 0;
+            }
+
+            if (pal_devs[i].id == PAL_DEVICE_OUT_USB_HEADSET) {
+                device_cap_query->id = PAL_DEVICE_OUT_USB_DEVICE;
+                device_cap_query->is_playback = true;
+            } else {
+                device_cap_query->id = PAL_DEVICE_IN_USB_DEVICE;
+                device_cap_query->is_playback = false;
+            }
+            device_cap_query->addr.card_id = adevice->usb_card_id_;
+            device_cap_query->addr.device_num = adevice->usb_dev_num_;
+            device_cap_query->config = &dynamic_media_config;
+            pal_get_param(PAL_PARAM_ID_DEVICE_CAPABILITY,
+                                 (void **)&device_cap_query,
+                                 &payload_size, nullptr);
+            pal_devs[i].address.card_id = adevice->usb_card_id_;
+            pal_devs[i].address.device_num = adevice->usb_dev_num_;
+            pal_devs[i].config.sample_rate = dynamic_media_config.sample_rate[0];
+            pal_devs[i].config.ch_info = ch_info;
+            pal_devs[i].config.aud_fmt_id = (pal_audio_fmt_t)dynamic_media_config.format[0];
+            free(device_cap_query);
+        } else {
+            pal_devs[i].config.sample_rate = DEFAULT_OUTPUT_SAMPLING_RATE;
+            pal_devs[i].config.bit_width = CODEC_BACKEND_DEFAULT_BIT_WIDTH;
+            pal_devs[i].config.ch_info = ch_info;
+            pal_devs[i].config.aud_fmt_id = PAL_AUDIO_FMT_DEFAULT_PCM;
+        }
+    }
+    AHAL_DBG("###### DPin Loopback exit");
+    return pal_stream_open(&sattr,
+            num_pal_devs, pal_devs,
+            0,
+            NULL,
+            pal_callback,
+            (uint64_t) this,
+            &dpin_loopback_stream_handle);
+}
+
+int AudioExtn::dpin_loopback_start() {
+    AHAL_DBG("###### DPin Loopback enter");
+    return pal_stream_start(dpin_loopback_stream_handle);
+}
+
+int AudioExtn::dpin_loopback_stop() {
+    AHAL_DBG("###### DPin Loopback enter");
+    return pal_stream_stop(dpin_loopback_stream_handle);
+}
+
+int AudioExtn::dpin_loopback_close(){
+    AHAL_DBG("###### DPin Loopback enter");
+    return pal_stream_close(dpin_loopback_stream_handle);
+}
+// END: DPin Loopback ==============================================================
+
 // START: PAL HIDL =================================================
 
 int AudioExtn::audio_extn_hidl_init() {
diff --git a/hal/audio_extn/inc/AudioExtn.h b/hal/audio_extn/inc/AudioExtn.h
index fcd23c94..03a13ce2 100644
--- a/hal/audio_extn/inc/AudioExtn.h
+++ b/hal/audio_extn/inc/AudioExtn.h
@@ -257,6 +257,12 @@ public:
     int karaoke_stop();
     int karaoke_close();
 
+    //DPin Loopback
+    int dpin_loopback_open(pal_device_id_t device_out, pal_stream_callback pal_callback, pal_channel_info ch_info);
+    int dpin_loopback_start();
+    int dpin_loopback_stop();
+    int dpin_loopback_close();
+
     /* start kpi optimize perf apis */
     static void audio_extn_kpi_optimize_feature_init(bool is_feature_enabled);
     static int audio_extn_perf_lock_init(void);
@@ -267,7 +273,7 @@ public:
 
     static bool isServiceRegistered() { return sServicesRegistered; }
 protected:
-    pal_stream_handle_t *karaoke_stream_handle;
+    pal_stream_handle_t *karaoke_stream_handle, *dpin_loopback_stream_handle;
     struct pal_stream_attributes sattr;
 private:
     static std::atomic<bool> sServicesRegistered;
