From f64938d0163033e944727d8226083e6b424a426c Mon Sep 17 00:00:00 2001
From: chenlijin <chenlj34@lenovo.com>
Date: Mon, 29 Sep 2025 15:32:44 +0800
Subject: [PATCH] [GEROLFING-2581] Multi-Camera 5/6: Add copyFrame

[scope of influence] Multi-Camera

[Type] feature

[RootCause] NA

[Solution] NA

Change-Id: I6462576a51936ab959bfd4b1a208bc7f8f89d0f0
Reviewed-on: https://vcsc.lenovo.com:8080/c/lenovo/lgsi/proprietary/camera/+/16772
Reviewed-by: GuoBin Zhang <zhanggb4@lenovo.com>
Tested-by: LiJin Chen <chenlj34@lenovo.com>
---

diff --git a/libcameraservice/cameraPandora/CameraPandora.cpp b/libcameraservice/cameraPandora/CameraPandora.cpp
index 2134552..1507583 100644
--- a/libcameraservice/cameraPandora/CameraPandora.cpp
+++ b/libcameraservice/cameraPandora/CameraPandora.cpp
@@ -9,6 +9,11 @@
 #include <sensor/SensorEventQueue.h>
 #include <cutils/properties.h>
 
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <linux/videodev2.h>
+#include <cstdlib>
+
 #include "Common.h"
 #include "CameraPandora.h"
 #include "Log.h"
@@ -50,6 +55,29 @@
     mPlatform = prop;
 
     mDump = property_get_bool("debug.camera.pandora.dump", false);
+
+    PANDORA_LOGI("FXA: CameraPandora start mCameraId: %d",mCameraId);
+    isCopyFrame = mCameraId == 0;
+    mVcamUsed = 2;
+ 
+    for (int i = 0; i < 2; i++){
+        std::string videoPath = "/dev/video" + std::to_string(i + 10);
+        PANDORA_LOGI("FXA: CameraPandora start videoPath: %s",videoPath.c_str());
+        mVcam[i] = open(videoPath.c_str(), O_RDWR);
+        PANDORA_LOGI("FXA: mVcam[%d]: %d", i, mVcam[i]);
+    }
+
+}
+
+std::vector<std::string> CameraPandora::splitString(const std::string& str, char delimiter) {
+    std::vector<std::string> tokens;
+    std::stringstream ss(str);
+    std::string item;
+
+    while (std::getline(ss, item, delimiter)) {
+        tokens.push_back(item);
+    }
+    return tokens;
 }
 
 CameraPandora::~CameraPandora()
@@ -63,6 +91,9 @@
     }
 
     SECURE_DELETE(mCameraPandoraImpl);
+    for (int i=0; i<mVcamUsed; i++) {
+        close(mVcam[i]);
+        }
 }
 
 void CameraPandora::setClientName(std::string client, int32_t level)
@@ -474,8 +505,8 @@
             return;
         }
 
-        PANDORA_LOGV("Camera Pandora: mPlatform %s stride:%d scanline:%d w:%d h:%d format:%d stride:%d",
-            mPlatform.c_str(), stride, scanline, width, height, format, buf->getStride());
+        PANDORA_LOGV("Camera Pandora: mPlatform %s stride:%d scanline:%d w:%d h:%d format:%d stride:%d cameraId:%d isCopyFrame:%d",
+            mPlatform.c_str(), stride, scanline, width, height, format, buf->getStride(),mCameraId,isCopyFrame);
 
         if (format == HAL_PIXEL_FORMAT_YCBCR_422_SP ||
             format == HAL_PIXEL_FORMAT_YCRCB_420_SP ||
@@ -537,6 +568,12 @@
                     gThis[mCameraId]->process(frame, mask, streamId);
                 }
 
+                if (isCopyFrame && format == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED) {
+                    for (int i=0; i<mVcamUsed; i++) {
+                        copyFrame(frame, mVcam[i]);
+                    }
+                }
+
                 if (mDump) {
                     dump(frame, "output");
                 }
@@ -728,8 +765,9 @@
     };
     static int frameId = 0;
     char filename[256];
-    sprintf(filename, "/data/camera/%d_%s_%dx%d.%s", frameId, prefix, frame.planes[0].stride, frame.planes[0].h,
-        formatstr[frame.format]);
+    sprintf(filename, "/sdcard/Download/%d_%s_%dx%d.yuv", frameId, prefix, frame.planes[0].stride, frame.h);
+    // sprintf(filename, "/data/camera/%d_%s_%dx%d.%s", frameId, prefix, frame.planes[0].stride, frame.planes[0].h,
+    //     formatstr[frame.format]);
     frameId++;
     FILE* fp = fopen(filename, "w");
     if (NOTNULL(fp)) {
@@ -743,5 +781,78 @@
     }
 }
 
+void CameraPandora::NV21toNV12(uint8_t *nv21, uint8_t *nv12, int32_t h, int32_t stride)
+{
+    PANDORA_LOGI("NV21 to NV12");
+	if(nv21 == nullptr || nv12 == nullptr){
+		return;
+	}
+    memcpy(nv12, nv21, stride * h);
+
+    for(int i = 0; i < stride * h / 2; i += 2){ 
+        nv12[stride * h + i + 1] = nv21[i + stride * h]; 
+        nv12[stride * h + i] = nv21[stride * h + i + 1];
+    }
 }
 
+void CameraPandora::NV12toNV21(uint8_t *nv12, uint8_t *nv21, int32_t h, int32_t stride)
+{
+    PANDORA_LOGI("NV12 to NV21");
+	if(nv12 == nullptr || nv21 == nullptr){
+		return;
+	}
+    memcpy(nv21, nv12, stride * h);
+
+    for(int i = 0; i < stride * h / 2; i += 2){ 
+        nv21[stride * h + i + 1] = nv12[i + stride * h]; 
+        nv21[stride * h + i] = nv12[stride * h + i + 1];
+    }
+}
+
+int32_t CameraPandora::copyFrame(FrameInfo &frame, int dev_fd) 
+{
+    PANDORA_LOGI("copy frame to virtual camera %d", dev_fd);
+
+    if (frame.planes[0].ptr == nullptr || frame.planes[1].ptr == nullptr) {
+        PANDORA_LOGE("image ptr is null!");
+        return -1;
+    }
+
+    struct v4l2_format v;
+    PANDORA_LOGI("frame.size: %zu", frame.size);
+    PANDORA_LOGI("frame.planes[0].stride: %d", frame.planes[0].stride);
+    PANDORA_LOGI("frame.h: %d", frame.h);
+
+    if (dev_fd == -1) {
+        PANDORA_LOGE("cannot open video device");
+        return -1;
+    }
+    v.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+    if (ioctl(dev_fd, VIDIOC_G_FMT, &v) == -1) {
+        PANDORA_LOGE("cannot read video device");
+        return -1;
+    }
+    v.fmt.pix.width = frame.planes[0].stride;
+    v.fmt.pix.height = frame.h;
+    v.fmt.pix.pixelformat = V4L2_PIX_FMT_NV12;
+    v.fmt.pix.sizeimage = frame.size;
+    v.fmt.pix.field = V4L2_FIELD_NONE;
+
+    PANDORA_LOGI("Setting V4L2 format:");
+    PANDORA_LOGI("  width: %d", frame.planes[0].stride);
+    PANDORA_LOGI("  height: %d", frame.h);
+    PANDORA_LOGI("  pixelformat: 0x%x", V4L2_PIX_FMT_NV12);
+    PANDORA_LOGI("  sizeimage: %zu", frame.size);
+    PANDORA_LOGI("  field: %d", V4L2_FIELD_NONE);
+
+    if ((ioctl(dev_fd, VIDIOC_S_FMT, &v) == -1)) {
+        PANDORA_LOGE("cannot write video device");
+        return -1;
+    }
+
+    write(dev_fd, frame.planes[0].ptr, frame.size);
+    
+    return 0;
+}
+
+}
\ No newline at end of file
diff --git a/libcameraservice/cameraPandora/CameraPandora.h b/libcameraservice/cameraPandora/CameraPandora.h
index f38b342..235632a 100644
--- a/libcameraservice/cameraPandora/CameraPandora.h
+++ b/libcameraservice/cameraPandora/CameraPandora.h
@@ -5,6 +5,8 @@
 #include <pthread.h>
 #include <atomic>
 #include <string>
+#include <sstream>
+#include <vector>
 
 #include "device3/Camera3StreamInterface.h"
 #include "CameraPandoraImpl.h"
@@ -42,7 +44,11 @@
     uint32_t getTagFromName(const char *name);
     void    YV12toNV12(uint8_t *yv12, uint8_t *nv12, int32_t h, int32_t stride);
     void    NV12toYV12(uint8_t *nv12, uint8_t *yv12, int32_t h, int32_t stride);
+    void    NV21toNV12(uint8_t *nv21, uint8_t *nv12, int32_t h, int32_t stride);
+    void    NV12toNV21(uint8_t *nv12, uint8_t *nv21, int32_t h, int32_t stride);
     void    dump(FrameInfo &frame, const char *prefix);
+    int32_t copyFrame(FrameInfo &frame, int dev_fd);
+    std::vector<std::string> splitString(const std::string& str, char delimiter);
 
 #ifdef ENABLE_CAMERASCREENRECORD
 private:
@@ -68,6 +74,9 @@
     std::map<int32_t, bool> mCroppedMap;
     bool                 mAutoframingUsingPlatform;
     bool                 mCropEnable; //avoid duplicate settings
+    int                mVcam[2];
+    int                mVcamUsed;
+    bool               isCopyFrame;
 
 };
 };
diff --git a/libcameraservice/cameraPandora/CameraPandoraImpl.cpp b/libcameraservice/cameraPandora/CameraPandoraImpl.cpp
index 15a7bd6..88e0cd2 100644
--- a/libcameraservice/cameraPandora/CameraPandoraImpl.cpp
+++ b/libcameraservice/cameraPandora/CameraPandoraImpl.cpp
@@ -99,7 +99,15 @@
                 PANDORA_LOGE("Failed to set xml root path, %d", rc);
             }
 
-            pandora::Source source = sourceMap[mCameraId];
+            // pandora::Source source = sourceMap[mCameraId];
+            // rsb added
+            pandora::Source source;
+            if (mCameraId > 1) {
+                source = pandora::Source::SOURCE_CAM_BACK_CUSTOM0;
+            } else {
+                source = sourceMap[mCameraId];
+            }
+
             mSwitchParser.readXmls(source,"/system/etc/camera/pandora");
         }
     }
@@ -117,7 +125,14 @@
         inputFrame.planes[i].scanline   = frame.planes[i].scanline;
         inputFrame.planes[i].dataLength = inputFrame.planes[i].stride * inputFrame.planes[i].scanline;
     }
-    pandora::Source source = sourceMap[mCameraId];
+    // pandora::Source source = sourceMap[mCameraId];
+    // rsb added
+    pandora::Source source;
+    if (mCameraId > 1) {
+        source = pandora::Source::SOURCE_CAM_BACK_CUSTOM0;
+    } else {
+        source = sourceMap[mCameraId];
+    }   
     pandora::Usecase usecase = pandora::Usecase::USECASE_ANY;
 
     if (streamId == 0) {
