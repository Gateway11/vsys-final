drive/drive-linux/kernel/source/nvidia-oot/sound/soc/tegra-virt-alt
1.change makefile
2.copy

3.change dts
drive/drive-foundation/platform-config/hardware/nvidia/platform/t264/automotive/kernel-dts/p3960/common/tegra264-p3960-sound.dtsi
                i2c@810c430000 {
                        status = "okay";
                        a2b24xx: a2b24xx@0x68 {
                        	compatible = "adi,a2b24xx";
                        	reg = <0x68>;
                        	status = "okay";
                	};
	            };

DAILINK_COMP_ARRAY(COMP_CODEC("a2b24xx.0", "a2b24xx-hifi")),
DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "a2b24xx-hifi")),

/* Command dispatch table */
static const struct a2b_command cmd_table[] = {
    {
        .prefix = "Reset",
        .min_args = 0,
        .handler = handle_reset,
        .description = "Reset controller"
    },
    {
        .prefix = "Log Enable",
        .min_args = 0,
        .handler = handle_log_enable,
        .description = "Log enable controller"
    },
    {
        .prefix = "Cancel Fault Check",
        .min_args = 0,
        .handler = handle_cancel_fault_check,
        .description = "Cancel fault check"
    },
    {
        .prefix = "Loopback Slave",
        .min_args = 1,
        .fmt = "Loopback Slave%hhd",
        .handler = handle_loopback_config,
        .description = "Configure loopback"
    },
    {
        .prefix = "RX Slave",
        .min_args = 2,
        .fmt = "RX Slave%hhd %hhd",
        .handler = handle_rx_config,
        .description = "Configure RX"
    },
    {
        .prefix = "PDM Slave",
        .min_args = 1,
        .fmt = "PDM Slave%d MIC%d",
        .handler = handle_pdm_config,
        .description = "Configure PDM"
    }
};

/* Command handler implementations */
static int handle_reset(struct a2b24xx *a2b24xx, int argc, int16_t *argv)
{
    a2b24xx_reset(a2b24xx);
    return 0;
}

static int handle_log_enable(struct a2b24xx *a2b24xx, int argc, int16_t *argv)
{
    a2b24xx->log_enabled = true;
    return 0;
}

static int handle_cancel_fault_check(struct a2b24xx *a2b24xx, int argc, int16_t *argv)
{
    a2b24xx_disable_fault_check(a2b24xx);
    return 0;
}

static int handle_loopback_config(struct a2b24xx *a2b24xx, int argc, int16_t *argv)
{
    a2b24xx_disable_fault_check(a2b24xx);
    if (argv[0] <= a2b24xx->final_node) {
        if (argv[0] < 0) {
            adi_a2b_I2CWrite(a2b24xx->dev, A2B_BASE_ADDR, 2, (uint8_t[]){A2B_REG_I2STEST, 0x06});
        } else {
            mutex_lock(&a2b24xx->bus_lock);
            adi_a2b_I2CWrite(a2b24xx->dev, A2B_BASE_ADDR, 2, (uint8_t[]){A2B_REG_NODEADR, argv[0]});
            adi_a2b_I2CWrite(a2b24xx->dev, A2B_BUS_ADDR, 2, (uint8_t[]){A2B_REG_I2STEST, 0x06});
            mutex_unlock(&a2b24xx->bus_lock); // Release lock
        }
    }
    return 0;
}

static int handle_rx_config(struct a2b24xx *a2b24xx, int argc, int16_t *argv)
{
    uint8_t config[] = {0x11, 0x91};
    pr_info("RX Slave(%d) (%d)\n", params[0], params[1]);

    uint8_t config[] = {0x11, 0x91};
    if (!(argv[0] < 0 || argv[0] > a2b24xx->final_node || argv[1] >= sizeof(config))) {
        mutex_lock(&a2b24xx->bus_lock);
        adi_a2b_I2CWrite(a2b24xx->dev, A2B_BASE_ADDR, 2, (uint8_t[]){A2B_REG_NODEADR, argv[0]});
        adi_a2b_I2CWrite(a2b24xx->dev, A2B_BUS_ADDR, 2, (uint8_t[]){A2B_REG_I2SCFG, config[argv[1]]});
        adi_a2b_I2CWrite(a2b24xx->dev, A2B_BUS_ADDR, 2, (uint8_t[]){A2B_REG_PDMCTL, 0x00});
        mutex_unlock(&a2b24xx->bus_lock); // Release lock
    }
    return 0;
}

/* Command dispatch table */
static const struct a2b_command cmd_table[] = {
    {"Reset", NULL, 0, handle_reset, "Reset controller"},
    {"Log Enable", NULL, 0, handle_log_enable, "Log enable controller"},
    {"Cancel Fault Check", NULL, 0, handle_cancel_fault_check, "Cancel fault check"},
    {"Loopback Slave", "%hd", 1, handle_loopback_config, "Configure loopback"},
    {"RX Slave", "%hd %hd", 2, handle_rx_config, "Configure RX"},
    {"PDM Slave", "%hd MIC%hd", 1, handle_pdm_config, "Configure PDM"},
};

/* Enhanced write operation for control interface */
static ssize_t a2b24xx_ctrl_write(struct file *file,
                        const char __user *buf, size_t count, loff_t *ppos)
{
    struct a2b24xx *a2b24xx = file->private_data;
    int16_t params[MAX_CMD_ARGS] = {0};
    int matched = 0, argc = 0;
    size_t len;

    len = min(count, sizeof(a2b24xx->command_buffer));
    if (copy_from_user(a2b24xx->command_buffer, buf, len))
        return -EFAULT;

    a2b24xx->command_buffer[len - 1] = '\0'; // Null-terminate the string
    pr_debug("Received command: %s\n", a2b24xx->command_buffer);

    /* Iterate through command dispatch table */
    for (int i = 0; i < ARRAY_SIZE(cmd_table); i++) {
        const struct a2b_command *cmd = &cmd_table[i];
        const size_t prefix_len = strlen(cmd->prefix);

        /* Match command prefix */
        if (strncmp(a2b24xx->command_buffer, cmd->prefix, prefix_len) != 0)
            continue;

        /* Parameter parsing */
        if (cmd->fmt) {
            argc = sscanf(a2b24xx->command_buffer + prefix_len + 1, 
                         cmd->fmt, &params[0], &params[1], 
                         &params[2], &params[3]);
        }

        /* Argument count validation */
        if (argc < cmd->min_args) {
            pr_warn("Invalid arguments for %s (required: %d, received: %d)\n",
                   cmd->prefix, cmd->min_args, argc);
            return -EINVAL;
        }

        /* Execute handler with error checking */
        if (cmd->handler(a2b24xx, argc, params) < 0)
            return -EIO;

        matched = 1;
        break; /* Stop after first match */
    }

    return matched ? len : -EINVAL;
}







/* Interrupt category flags (bitmask) */
typedef enum {
    INT_FLAG_ERROR     = 0x01,  /* Critical error requiring handling */
    INT_FLAG_IGNORABLE = 0x02,  /* Non-critical interrupt that can be ignored */
    INT_FLAG_REPORT    = 0x04   /* Requires external reporting/notification */
} IntCategory;

/* Interrupt descriptor structure */
typedef struct {
    uint8_t type;               /* Interrupt type identifier */
    uint8_t flags;              /* Category flags (bitmask of IntCategory) */
    const char *message;        /* Human-readable description */
    void (*report_cb)(uint8_t int_type, void *context); /* Reporting callback */
} IntTypeInfo_t;

/* Example report handlers */
static void report_power_error(uint8_t int_type, void *context) {
    struct a2b24xx *dev = (struct a2b24xx *)context;
    pr_err("Power error %02X: %s\n", int_type, dev->last_error);
    notify_system_monitor(int_type);
}

static void report_spi_error(uint8_t int_type, void *context) {
    log_to_audit_system("SPI fault", int_type);
}

/* Interrupt configuration table */
const IntTypeInfo_t intTypeInfo[] = {
    /* Format: {TYPE, FLAGS, DESCRIPTION, CALLBACK} */
    {A2B_ENUM_INTTYPE_HDCNTERR,
     INT_FLAG_ERROR | INT_FLAG_REPORT,
     "Header count error",
     report_power_error},

    {A2B_ENUM_INTTYPE_PWRERR_CS_GND,
     INT_FLAG_ERROR | INT_FLAG_REPORT,
     "PWRERR (Cable Shorted to GND)",
     report_power_error},

    {A2B_ENUM_INTTYPE_DDERR,
     INT_FLAG_ERROR,
     "Data decoding error",
     NULL},

    {A2B_ENUM_INTTYPE_SPI_REMOTE_REG_ERR,
     INT_FLAG_REPORT,
     "SPI remote register error",
     report_spi_error},

    {A2B_ENUM_INTTYPE_IO0PND,
     INT_FLAG_IGNORABLE,
     "IO0 pending (Slave)",
     NULL},

    {A2B_ENUM_INTTYPE_I2CERR,
     INT_FLAG_ERROR | INT_FLAG_REPORT,
     "I2C communication error",
     report_spi_error}
};
